The {\tt PSTA} algorithm is shown in Algorithm \ref{algo:PSTA1},
\ref{algo:PSTA2} and \ref{algo:PSTA3}. Algorithm \ref{algo:PSTA1}
shows the computation of the leaves of the {\tt RMMT}, Algorithm
\ref{algo:PSTA2} shows the computation of the internal nodes of the
{\tt RMMT} and finally Algorithm \ref{algo:PSTA3} shows the
computation of the universal tables. The sequential version of {\tt
  PSTA} can be obtained by replacing {\bf parfor} instruction with
sequential {\bf for} instructions. The algorithm takes as input a parentheses
sequence $P$ of size $2n$, the arity $k$ of the internal nodes in the {\tt
  RMMT}, the size of each chunk $s$ and the total numbers of available
threads. In the sequence $P$, opened-parenthesis and
closed-parenthesis are coded by a $1$ and a $0$, respectively. The
output is the {\tt RMMT} represented by its arrays $e^{\prime}$,
$m^{\prime}$, $M^{\prime}$, $n^{\prime}$ and universal tables to
support queries in $O(\lg n)$ time.

Let's first analyze Algorithm \ref{algo:PSTA1}. Since the {\tt RMMT}
can be seen as a complete tree of arity $k$, it is easy to calculate
the size of the arrays $e^{\prime}$, $m^{\prime}$, $M^{\prime}$ and
$n^{\prime}$. The size of array $e^{\prime}$ is the number of leaves
in the {\tt RMMT} (line 2). The size of arrays $m^{\prime}$,
$M^{\prime}$ and $n^{\prime}$ is equal to the total number of nodes in
the {\tt RMMT}; that is, $\frac{\lceil 2n/s \rceil-1}{k-1} + \lceil
2n/s \rceil$ (lines 1 and 3). Lines 4 to 26 shows the computation of
partial excess values in parallel. The first step is to compute the
number of chunks that each thread has to process (line 4). Then, in
parallel, each thread computes the excess value of $ct$ consecutive
chunks, following the equation to compute excess values. In each chunk, the
thread increases by one its partial excess value each time that an
open parenthesis appears, and decreases by one in the other case
(lines 12 to 15). Immediately after the partial excess changes, it is
necessary to verify if the maximum, minimum and number of minimum
values also change (lines 16 to 22). When a chunk is completed, the
local excess and its associated values are stored in the arrays
$e^{\prime}$, $m^{\prime}$, $M^{\prime}$ and $n^{\prime}$ (lines 23 to
26). After a thread finishes processing its chunks, it is necessary to
complement its local excess values considering the local values of
previous threads. To do that, we first update the final excess value
of each thread using a parallel prefix sum algorithm (line 27). 
Those excess values do not need to be modified again. Observe that
the prefix sum algorithm only needs to consider $p$ values, at positions
$i*ct-1$, with $1\leq i \leq p-1$. Due to the updated final excess value,
each thread can update the other excess, minimum and maximum values in
parallel (lines 28 to 33). At this point, {\tt PSTA} has computed all
the leaves of the {\tt RMMT} in parallel.

Algorithm \ref{algo:PSTA2} shows the computation of the internal
nodes, which has two substeps: The first substep computes $O(p)$
subtrees in parallel (lines 2 to 18) and the second one computes the
top of the {\tt RMMT} (lines 19 to 34). To ensure that $O(p)$ subtrees
will be computed in parallel, it is necessary to compute the closest
level to the root that has at least $p$ subtrees (line 1). After that,
{\tt PSTA} computes in parallel each subtree at that level. Each
thread computes each node of the corresponding subtree by scanning the
$k$ children of that node, obtaining the corresponding minimum and
maximum values (lines 3 to 18). Notice that one thread can compute
more than one subtree and those subtrees can be non-consecutive. With
a scheduler that balances the work, such as a work-stealing scheduler,
threads have a similar workload. In the second substep, the $O(\lceil
\log_{k}p \rceil)$ levels of the top of the {\tt RMMT} are computed in
parallel. The {\tt PSTA} algorithm assigns one node per thread,
computing each level in $O(k)$ time.

In the last step of {\tt PSTA}, Algorithm \ref{algo:PSTA3} shows the computation of
universal tables. To simplify the explanation, Algorithm
\ref{algo:PSTA3} just shows the computation of one universal table,
$near\_fwd\_pos$, used to compute the \emph{fwd\_ search} operation. The same algorithm can be applied to the other
tables. All of these tables do not depend on the input, except for the
number of available threads.
\begin{minipage}[t]{.50\textwidth}
  \vspace{0pt}  
  \begin{algorithm}[H]
\small
\SetVlineSkip{-2cm}
  % keywords
  \SetKwInOut{Input}{Input}
  \SetKwInOut{output}{output}
  \SetKwFor{PFor}{parfor}{do}{end}
  \LinesNumbered
  \SetAlgoNoEnd
  \DontPrintSemicolon
  % I/o
  \Input{$P$, $k$, $s$, $threads$}
  \output{$e^{\prime}, m^{\prime}, M^{\prime}, n^{\prime}$ and universal tables ({\tt RMMT})}
  \BlankLine% \SetAlgoNoLine
  % algorithm
  $o$ = $\frac{\lceil 2n/s \rceil-1}{k-1}$\tcp*[h]{\# internal nodes}\;
  $e^{\prime}$ = array of size $\lceil 2n/s \rceil$\;
  $m^{\prime}, M^{\prime}, n^{\prime}$ = arrays of size $\lceil 2n/s \rceil + o$\;
  $ct$ = $\lceil 2n/s \rceil/threads$\;%\tcp*[h]{Chunks per thread}\;
  \PFor{$t\leftarrow 0$ \KwTo $threads-1$}{
	  $e^{\prime}_t, m^{\prime}_t, M^{\prime}_t, n^{\prime}_t$ = $0$\;
	  
	  \For{$chk \leftarrow 0$ \KwTo $ct$}{
		  $low$ = $t*ct*s+chk*s$\;
		  $up$ = $low+s$\;
	  	
		  \For{$par \leftarrow low$ \KwTo $up$}{
		  	\eIf{$P[par]$ is $closed$}{
		  		$e^{\prime}_t$ -= $1$\;
		  	}
		    {
		  		$e^{\prime}_t$ += $1$\;
		    }
		    
		    \uIf{$e^{\prime}_t < m^{\prime}_t$}{
				$m^{\prime}_t$ = $e^{\prime}_t$\;
				$n^{\prime}_t$ = $1$
			}
			\uElseIf{$e^{\prime}_t == m^{\prime}_t$}{
				$n^{\prime}_t$ += $1$\;
			}
			\uElseIf{$e^{\prime}_t > M^{\prime}_t$}{
				$M^{\prime}_t$ = $e^{\prime}_t$\;
			}
		  }
		  $e^{\prime}[t*ct+chk]$ = $e^{\prime}_t$\;
		  $m^{\prime}[t*ct+chk+o]$ = $m^{\prime}_t$\;
		  $M^{\prime}[t*ct+chk+o]$ = $M^{\prime}_t$\;
		  $n^{\prime}[t*ct+chk+o]$ = $n^{\prime}_t$\;		  
	  }
  }
  \BlankLine
  $parallel\_prefix\_sum(e^{\prime}, ct)$\;
%  \For{$t \leftarrow 1$ \KwTo $threads-1$}{
%		$e^{\prime}[(t+1)*ct-1]$ += $e^{\prime}[t*ct-1]$\;
 % }
  \BlankLine
  \PFor{$t\leftarrow 1$ \KwTo $threads-1$}{
	  \For{$chk \leftarrow 0$ \KwTo $ct$}{
	  	\If{$t == threads-1$ OR $chk < ct-1$}{
	  	  $e^{\prime}[t*ct+chk]$ += $e^{\prime}[t*ct-1]$\;
	  	}
  	  	$m^{\prime}[t*ct+chk+o]$ += $e^{\prime}[t*ct-1]$\;
  	  	$M^{\prime}[t*ct+chk+o]$ += $e^{\prime}[t*ct-1]$\;
	  }
  }
%  \Return{$WT$}\;
  \caption{{\tt PSTA} (part I)}
  \label{algo:PSTA1}
  \end{algorithm}
\end{minipage}%
%hfill
\begin{minipage}[t]{.51\textwidth}
  \vspace{0pt}
  \begin{algorithm}[H]
\small
\SetVlineSkip{-2cm}
  % keywords
%  \SetKwInOut{Input}{Input}
%  \SetKwInOut{output}{output}
  \SetKwFor{PFor}{parfor}{do}{end}
  \LinesNumbered
  \SetAlgoNoEnd
  \DontPrintSemicolon
  % I/o
%  \Input{Parentheses sequence $P$, $k$, $s$, $threads$}
%  \output{$e^{\prime}, m^{\prime}, M^{\prime}, n^{\prime}$ and universal tables ({\tt RMMT})}
%  \BlankLine%
  \SetAlgoLined
%\setcounter{AlgoLine}{2}
%\ShowLn
  % algorithm
  \setcounter{AlgoLine}{1}\ShowLn
  $lvl$ = $\lceil \log_{k}threads \rceil$\;
  \setcounter{AlgoLine}{2}\ShowLn
  \PFor{$st\leftarrow 0$ \KwTo $k^{lvl}$}{
      \setcounter{AlgoLine}{3}\ShowLn
	  \For{$l\leftarrow \lceil\log_{k}(2n/s)\rceil-1$ \KwTo $lvl$}{
          \setcounter{AlgoLine}{5}\ShowLn
		  \For{$d\leftarrow 0$ \KwTo $k^{l-lvl}$}{
            \setcounter{AlgoLine}{5}\ShowLn
		  	$i$ = $d + k^{l} - 1 +st*k^{l-lvl}$\;
            \setcounter{AlgoLine}{6}\ShowLn
		  	$b$ = $i*k+1$\;
            \setcounter{AlgoLine}{7}\ShowLn
			\For{$c\leftarrow b$ \KwTo $b+k-1$}{
%****
                \setcounter{AlgoLine}{8}\ShowLn
			  	\uIf{$c == b$}{
                  \setcounter{AlgoLine}{9}\ShowLn
				  $m^{\prime}[i]$ = $m^{\prime}[c]$\;
                  \setcounter{AlgoLine}{10}\ShowLn
				  $M^{\prime}[i]$ = $M^{\prime}[c]$\;
                  \setcounter{AlgoLine}{11}\ShowLn
				  $n^{\prime}[i]$ = $n^{\prime}[c]$\;					
			  	}
                \setcounter{AlgoLine}{12}\ShowLn
			    \uElseIf{$m^{\prime}[c] < m^{\prime}[i]$}{
                    \setcounter{AlgoLine}{13}\ShowLn
					$m^{\prime}[i]$ = $m^{\prime}[c]$\;
                    \setcounter{AlgoLine}{14}\ShowLn
					$n^{\prime}[i]$ = $n^{\prime}[c]$\;
				}
                \setcounter{AlgoLine}{15}\ShowLn
				\uElseIf{$m^{\prime}[c] == m^{\prime}[i]$}{
                    \setcounter{AlgoLine}{16}\ShowLn
					$n^{\prime}[i]$ += $n^{\prime}[c]$\;
				}
                \setcounter{AlgoLine}{17}\ShowLn
				\uElseIf{$M^{\prime}[c] > M^{\prime}[i]$}{
                    \setcounter{AlgoLine}{18}\ShowLn
					$M^{\prime}[i]$ = $M^{\prime}[c]$\;
				}
%****
		    						
%			  	\eIf{$c == b$}{
%				  $m^{\prime}[i]$ = $m^{\prime}[c]$\;
%				  $M^{\prime}[i]$ = $M^{\prime}[c]$\;
%				  $n^{\prime}[i]$ = $n^{\prime}[c]$\;					
%			  	}
%			    	{
%				    \uIf{$m^{\prime}[c] < m^{\prime}[i]$}{
%						$m^{\prime}[i]$ = $m^{\prime}[c]$\;
%						$n^{\prime}[i]$ = $n^{\prime}[c]$\;
%					}
%					\uElseIf{$m^{\prime}[c] == m^{\prime}[i]$}{
%						$n^{\prime}[i]$ += $n^{\prime}[c]$\;
%					}
%					\uElseIf{$M^{\prime}[c] > M^{\prime}[i]$}{
%						$M^{\prime}[i]$ = $M^{\prime}[c]$\;
%					}
%		    		}
			}		  	
		  }
	  }
  }
  \BlankLine
  \setcounter{AlgoLine}{19}\ShowLn
  \For{$l\leftarrow lvl-1$ \KwTo $0$}{
	  \setcounter{AlgoLine}{20}\ShowLn
	  \PFor{$d\leftarrow 0$ \KwTo $k^{l}$}{
        \setcounter{AlgoLine}{21}\ShowLn
	  	$i$ = $d + (k^{l}-1)/(k-1)$\;
        \setcounter{AlgoLine}{22}\ShowLn
	  	$b$ = $i*k+1$\;
        \setcounter{AlgoLine}{23}\ShowLn
		\For{$c\leftarrow b$ \KwTo $b+k-1$}{
%****		
            \setcounter{AlgoLine}{24}\ShowLn
		  	\uIf{$ch == b$}{
              \setcounter{AlgoLine}{25}\ShowLn
			  $m^{\prime}[i]$ = $m^{\prime}[c]$\;
              \setcounter{AlgoLine}{26}\ShowLn
			  $M^{\prime}[i]$ = $M^{\prime}[c]$\;
              \setcounter{AlgoLine}{27}\ShowLn
			  $n^{\prime}[i]$ = $n^{\prime}[c]$\;					
		  	}
            \setcounter{AlgoLine}{28}\ShowLn
		    \uElseIf{$m^{\prime}[c] < m^{\prime}[i]$}{
                \setcounter{AlgoLine}{29}\ShowLn
				$m^{\prime}[i]$ = $m^{\prime}[c]$\;
                \setcounter{AlgoLine}{30}\ShowLn
				$n^{\prime}[i]$ = $n^{\prime}[c]$\;
			}
            \setcounter{AlgoLine}{31}\ShowLn
			\uElseIf{$m^{\prime}[c] == m^{\prime}[i]$}{
                \setcounter{AlgoLine}{32}\ShowLn
				$n^{\prime}[i]$ += $n^{\prime}[c]$\;
			}
            \setcounter{AlgoLine}{33}\ShowLn
			\uElseIf{$M^{\prime}[c] > M^{\prime}[i]$}{
                \setcounter{AlgoLine}{34}\ShowLn
				$M^{\prime}[i]$ = $M^{\prime}[c]$\;
			}
%****		
	    		
%		  	\eIf{$ch == b$}{
%			  $m^{\prime}[i]$ = $m^{\prime}[c]$\;
%			  $M^{\prime}[i]$ = $M^{\prime}[c]$\;
%			  $n^{\prime}[i]$ = $n^{\prime}[c]$\;					
%		  	}
%		    	{
%			    \uIf{$m^{\prime}[c] < m^{\prime}[i]$}{
%					$m^{\prime}[i]$ = $m^{\prime}[c]$\;
%					$n^{\prime}[i]$ = $n^{\prime}[c]$\;
%				}
%				\uElseIf{$m^{\prime}[c] == m^{\prime}[i]$}{
%					$n^{\prime}[i]$ += $n^{\prime}[c]$\;
%				}
%				\uElseIf{$M^{\prime}[c] > M^{\prime}[i]$}{
%					$M^{\prime}[i]$ = $M^{\prime}[c]$\;
%				}
%	    		}
		}		  	
	  }
  }
  \caption{{\tt PSTA} (part II)}
  \label{algo:PSTA2}
	  \end{algorithm}
\end{minipage}